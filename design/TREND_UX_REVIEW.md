# Trend (30m) 구현 리뷰

## 1. 의미 추론 (코드 기반)

**Trend = “30분 단위로 집계한 평균 대역폭의 시계열”**

- **Real-time**: 현재 테스트의 iperf3 텍스트 출력을 파싱해 **초 단위** 구간별 대역폭을 그대로 그래프에 표시 (예: 0–1초, 1–2초 …).
- **Trend**: **30분(1,800,000ms)** 간격으로, 그동안 수집한 모든 iperf 출력 라인에서 파싱한 대역폭 값들의 **평균(avg)** 을 한 점으로 만들어 시계열로 표시.  
  즉 “지난 30분 동안 iperf 클라이언트가 보고한 대역폭 샘플들의 평균”이 하나의 점이 됨.

추가로 코드에서:
- `min`/`max`도 계산해 `{ time, bandwidth: avg, min, max }` 형태로 저장하지만, **차트에는 avg만 사용**하고 min/max는 미표시.
- 데이터는 **앱 전역** 한 곳(`iperfLongTermData`)에만 있고, **세션/호스트 구분 없음**.
- 최대 **500개** 점 유지 → 30분 간격이면 약 **250시간(≈10일)** 분량.

---

## 2. 구현 요약

| 구분 | 위치 | 동작 |
|------|------|------|
| 수집 | `App.jsx` `handleClientOutput` | iperf 클라이언트 stdout/stderr 청크마다 `parseIperfLine(line)`으로 대역폭 추출 → `aggregationBuffer`에 push |
| 집계 | 동일 | `Date.now() - lastAggregationTime >= 1_800_000` 일 때 buffer의 avg/min/max 계산 → `iperfLongTermData`에 한 점 추가, buffer 비움 |
| 저장 | `App.jsx` | `setIperfLongTermData(prev => [...prev, newPoint].slice(-500))` |
| 전달 | App → TerminalView → SessionContent → IperfClientSidebar | `longTermData` prop |
| 표시 | `IperfClientSidebar.jsx` | `graphView === 'trend'` 일 때 `trendData`(longTermData)로 AreaChart, X축은 `time`(timestamp), Y축은 `bandwidth`(avg) |

---

## 3. UX 관점 검토

### 3.1 의도 추정

- “지금 돌리는 한 번의 테스트”가 아니라 **시간이 지나면서 대역폭이 어떻게 변했는지**를 보고 싶은 사용자(예: 수 시간/며칠 단위 모니터링)를 위한 뷰로 보임.
- Real-time은 “이번 런” 한 번의 곡선, Trend는 “여러 런/긴 시간”을 30분 단위로 요약한 곡선.

### 3.2 UX상 문제점

1. **30분이 지나야 첫 점이 생김**  
   - 짧은 테스트(예: 10초, 1분)만 돌리는 일반 사용자는 Trend를 켜도 **항상 비어 있음**.  
   - “Trend (30m)”만 보고는 “30분이 지나야 데이터가 쌓인다”는 걸 알기 어렵고, **버튼이 비활성화된 이유**도 불명확함(데이터 없음일 때만 disabled).

2. **집계 단위가 고정 30분**  
   - 30분은 “긴 모니터링”에 가깝고, 일반적인 iperf 사용(몇 분~몇십 분)과는 잘 안 맞을 수 있음.  
   - 1분/5분/10분 등 **선택 가능한 집계 구간**이 없어 “의미”를 맞추기 어려움.

3. **전역 단일 시계열**  
   - 모든 세션/모든 대상(호스트)의 iperf 클라이언트 결과가 **한 트렌드에 섞임**.  
   - “A 서버로 1시간, B 서버로 1시간” 돌렸을 때 트렌드가 “A와 B가 섞인 평균”이 되어, **어디에 대한 트렌드인지** 해석이 애매함.  
   - 세션/호스트별로 나누거나, “현재 세션만” 같은 필터가 있으면 더 직관적일 수 있음.

4. **min/max 미표시**  
   - 이미 계산해 두었는데 차트에는 avg만 사용.  
   - 트렌드에서 “그 30분 안에서 얼마나 들쭉날쭉했는지”를 보려면 min/max 밴드나 툴팁에 넣는 편이 의미가 더 분명해짐.

5. **설명 부재**  
   - “Trend (30m)” 라벨만으로는 “30분 구간 평균”인지, “30분치 데이터”인지, “언제부터 쌓이는지” 사용자가 추론하기 어려움.  
   - 짧은 도움말(툴팁/설명 문구)이 있으면 “의미”와 “언제 보이는지”를 이해하기 쉬움.

6. **Real-time과 스케일/의도가 다름**  
   - Real-time: X축 “초”, 한 테스트의 짧은 구간.  
   - Trend: X축 “시각(시간)”, 30분 단위 요약.  
   - 같은 “대역폭 그래프”인데 축 의미가 완전히 달라서, 전환 시 “뭘 보는 건지” 헷갈릴 수 있음. 라벨/축 설명이 있으면 좋음.

### 3.3 잘 맞는 부분

- Real-time / Trend **토글**로 “지금 이번 런” vs “시간에 따른 추이”를 나누는 개념은 직관적.
- 데이터가 없을 때 Trend 버튼을 비활성화하는 것은 합리적이나, **비활성화 이유**(예: “30분 이상 데이터 필요”)는 추가 설명이 있으면 좋음.
- 500점 상한으로 메모리/성능은 제한된 구현으로 적절해 보임.

---

## 4. 결론 및 제안

- **의미**: Trend는 “**30분 단위 평균 대역폭 시계열**”로, **장시간/반복 모니터링**용 뷰로 추정됨.
- **현재 구현**: 집계·저장·전달·표시 흐름은 일관되나, **30분 고정·전역 단일 시계열·설명 부재** 때문에 “일반적인 짧은 iperf 테스트” 사용자에게는 **의미가 잘 전달되지 않고**, “긴 시간 대역폭 추이를 보는 사람”에게만 유용한 상태로 보임.

**UX에 더 부합시키려면:**

1. **설명 추가**: “Trend (30m)” 옆에 툴팁 또는 짧은 문구  
   - 예: “30분 구간 평균. 30분 이상 데이터가 쌓인 후 표시됩니다.”
2. **데이터 없을 때**: Trend 선택 시 빈 차트 영역에 문구  
   - 예: “30분마다 평균이 기록됩니다. iperf 클라이언트를 더 오래 실행하면 트렌드가 표시됩니다.”
3. **(선택)** 집계 간격을 1/5/10/30분 중 선택 가능하게 하거나, 최소 “1분” 같은 옵션을 두면 짧은 사용에도 트렌드가 금방 보이게 할 수 있음.
4. **(선택)** min/max를 툴팁에 표시하거나, 영역(밴드)으로 그리면 “그 30분 안의 변동”까지 전달 가능.
5. **(선택)** “현재 세션만” / “전체” 같은 필터를 두면 “어디에 대한 트렌드인지”가 명확해짐.

이렇게 정리하면 “Trend가 무엇인지”와 “언제/어떻게 쓰면 좋은지”가 사용자에게 더 잘 맞게 전달될 가능성이 높습니다.
