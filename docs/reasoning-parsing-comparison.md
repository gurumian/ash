# Reasoning 파싱 방식 비교

## 현재 방식: 정규식 파싱 (백엔드에서 분리)

### 작동 방식

1. **LLM이 생성한 응답 예시:**
```
<thinking>
사용자가 파일 목록을 요청했습니다. ls 명령을 실행해야 합니다.
먼저 현재 디렉토리를 확인한 후 파일 목록을 가져오겠습니다.
</thinking>

다음은 현재 디렉토리의 파일 목록입니다:

\`\`\`
file1.txt
file2.txt
directory/
\`\`\`
```

2. **백엔드에서 정규식으로 파싱** (`app.py:303`):
```python
match = re.search(r'<thinking>(.*?)</thinking>', content, re.DOTALL)
if match:
    reasoning_content = match.group(1).strip()  # 태그 내용만 추출
    display_content = content.replace(match.group(0), '').strip()  # 태그 제거
```

3. **두 개의 별도 이벤트로 전송:**
```json
// 첫 번째 이벤트
{
  "type": "reasoning",
  "content": "사용자가 파일 목록을 요청했습니다. ls 명령을 실행해야 합니다.\n먼저 현재 디렉토리를 확인한 후 파일 목록을 가져오겠습니다."
}

// 두 번째 이벤트
{
  "type": "content",
  "content": "다음은 현재 디렉토리의 파일 목록입니다:\n\n```\nfile1.txt\nfile2.txt\ndirectory/\n```"
}
```

4. **프론트엔드에서 별도 처리:**
   - `reasoning` 타입 → 회색 텍스트로 별도 렌더링
   - `content` 타입 → 일반 응답으로 렌더링

### 문제점

- ❌ **LLM이 태그 형식을 정확히 따르지 않으면 파싱 실패**
  - 예: `<thinking>` 대신 `<thinking >` (공백) → 파싱 안됨
  - 예: `</thinking>` 누락 → 파싱 안됨
  - 예: 여러 개의 `<thinking>` 태그 → 첫 번째만 파싱
  
- ❌ **정규식이 실패하면 reasoning과 content가 혼재**
  - 파싱 실패 시 전체가 `display_content`로 전송됨
  - 사용자에게 `<thinking>` 태그가 그대로 보일 수 있음

- ❌ **스트림 이벤트가 2개로 분리되어 UI 업데이트가 복잡**
  - reasoning 업데이트 → content 업데이트 순서로 처리 필요
  - 순서가 바뀌거나 하나만 도착하면 UI가 이상하게 보임

---

## 제안 방식: Content를 그대로 전송 (백엔드 파싱 제거)

### 작동 방식

1. **LLM이 생성한 응답 그대로:**
```
<thinking>
사용자가 파일 목록을 요청했습니다. ls 명령을 실행해야 합니다.
먼저 현재 디렉토리를 확인한 후 파일 목록을 가져오겠습니다.
</thinking>

다음은 현재 디렉토리의 파일 목록입니다:

\`\`\`
file1.txt
file2.txt
directory/
\`\`\`
```

2. **백엔드에서 파싱 없이 그대로 전송:**
```python
# 정규식 파싱 제거
if event_type == 'assistant':
    if content:
        # 파싱 없이 전체 content를 그대로 전송
        yield f"data: {json.dumps({'type': 'content', 'content': content})}\n\n"
```

3. **단일 이벤트로 전송:**
```json
{
  "type": "content",
  "content": "<thinking>\n사용자가 파일 목록을 요청했습니다...\n</thinking>\n\n다음은 현재 디렉토리의 파일 목록입니다:\n\n```\n..."
}
```

4. **프론트엔드에서 처리 (선택적):**
   - Option A: Markdown으로 렌더링 → `<thinking>` 태그가 HTML로 변환되어 표시
   - Option B: 프론트엔드에서 파싱하여 스타일링
   - Option C: 그대로 표시 (사용자가 태그를 볼 수 있음)

### 장점

- ✅ **안정적**: LLM 출력 형식에 의존하지 않음
- ✅ **단순함**: 백엔드 로직이 단순해짐
- ✅ **유연함**: 프론트엔드에서 필요에 따라 처리 가능
- ✅ **단일 이벤트**: UI 업데이트가 더 단순

### 단점

- ⚠️ **프론트엔드에서 파싱 필요** (원하는 경우)
- ⚠️ **태그가 사용자에게 보일 수 있음** (마크다운 렌더링 방식에 따라)

---

## 비교 요약

| 구분 | 현재 방식 (정규식 파싱) | 제안 방식 (그대로 전송) |
|------|------------------------|------------------------|
| **백엔드 복잡도** | 높음 (정규식 파싱 로직) | 낮음 (단순 전송) |
| **안정성** | 낮음 (태그 형식 의존) | 높음 (형식 독립적) |
| **프론트엔드 복잡도** | 중간 (2개 이벤트 처리) | 낮음 (1개 이벤트) |
| **UI 떨림 가능성** | 높음 (2개 이벤트 분리) | 낮음 (단일 이벤트) |
| **Reasoning 표시** | 별도 렌더링 가능 | 마크다운으로 처리 |

---

## 추천

**Content를 그대로 전송하는 방식**을 추천합니다:
1. 정규식 파싱의 불안정성 제거
2. UI 업데이트 단순화
3. 프론트엔드에서 필요시 `<thinking>` 태그를 마크다운 HTML로 렌더링하면 자동으로 처리됨

